from tkinter import *
import tkinter as tk
import cv2
import face_recognition
import numpy as np
import os
from datetime import datetime
#List to hold all the rooms needs to be created
Rooms = []
#Generate a security Report
Report = ""
#Root component of GUi
root = Tk()
root.title("My App")
root.geometry("800x400")
root.maxsize(1200, 800)
count = 0
parent_dir = "C:/Users/user/PycharmProjects/GUI"


# function to see reports Generated by the algorithm
def reports():
    root2 = Tk()
    root2.title("Reports")
    root2.geometry("500x500")

    if Report == '':
        txt3 = "No Error Reported So far"
    else:
        txt3 = Report
    label_r = Label(root2, text=txt3)
    label_r.pack()
    root2.update()
    root2.mainloop()


# find the encodings for the faces that are passed to the function
def find_encodings(images):
    encoded_list = []
    for img in images:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        encode = face_recognition.face_encodings(img)[0]
        encoded_list.append(encode)
    return encoded_list


# function to mark new attendance only if the attendance is not marked previously
def mark_attendance(name,rm):
    with open('record.csv', 'r+') as f:
        mydata = f.readlines()
        name_list = []
        for line in mydata:
            entry = line.split(',')
            name_list.append(entry[0])
        if name not in name_list:
            now = str(datetime.now())
            f.writelines(f'\n{name},{now},{rm}')
            global count
            count = count + 1
    f.close()


# function working in GUI to identify for which room should the algorithm work on
def rooms_work(r_number):
    txt1 = 'Encoding Images in ' + r_number + '.'
    label2.configure(text=txt1)
    root.update()
    room_setup(r_number)


# setup each room by getting the images and from directory
def room_setup(pth):
    path = pth
    images = []
    classnames = []
    myList = os.listdir(path)
    number_of_students = len(myList)
    print(number_of_students)
    global count
    count = 0
    for cls in myList:
        curImg = cv2.imread(f'{path}/{cls}')
        images.append(curImg)
        classnames.append(os.path.splitext(cls)[0])

    encoded_known_list = find_encodings(images)
    txt1 = "Encoding for " + pth + " completed."
    label2.configure(text=txt1)
    root.update()
    cap = cv2.VideoCapture(0)
    ch = TRUE
    ffDis = [0.893245]
    while ch:
        success, img = cap.read()
        imgS = cv2.resize(img, (0, 0), None, 0.25, 0.25)
        imgS = cv2.cvtColor(imgS, cv2.COLOR_BGR2RGB)
        facesCurFrame = face_recognition.face_locations(imgS)
        encodeCurFrame = face_recognition.face_encodings(imgS, facesCurFrame)
        for encodeFace, faceLoc in zip(encodeCurFrame, facesCurFrame):
            # returns true or false after comparing the faces
            matches = face_recognition.compare_faces(encoded_known_list, encodeFace)
            # returns an array of distance between the captured face encodings and encodings of faces in the room
            faceDis = face_recognition.face_distance(encoded_known_list, encodeFace)
            ffDis = faceDis
            #returns the minimum value
            matchIndex = np.argmin(faceDis)
            if matches[matchIndex]:
                name = classnames[matchIndex].upper()
                y1, x2, y2, x1 = faceLoc
                y1, x2, y2, x1 = y1*4, x2*4, y2*4, x1*4
                cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
                cv2.rectangle(img, (x1, y2 - 35), (x2, y2), (0, 255, 0), cv2.FILLED)
                cv2.putText(img, name, (x1 + 6, y2 - 6), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 2)
                mark_attendance(name,pth)
        if count < number_of_students:
            ch = TRUE
        else:
            ch = FALSE
        count1 = 0
        for dis in ffDis:
            if dis > 0.70:
                count1 = count1 + 1
        if count1 > 0:
            global Report
            if Report == "No Error Reported So far" or Report == "":
                Report = "Unauthorized Face Detected @" + str(datetime.now()) + " in " + pth
                name = "Security_Report/" + str(datetime.now()) + ".jpg"
                name = name.replace(" ", "")
                name = name.replace("-", "_")
                name = name.replace(":", "_")
                print(name)
                status = cv2.imwrite(name, img)
                print(status)
            else:
                securityList = os.listdir("Security_Report")
                securityImages = []
                for cls in securityList:
                    currImg = cv2.imread(f'{"Security_Report"}/{cls}')
                    securityImages.append(currImg)
                encoded_security_list = find_encodings(securityImages)
                SecurityFCurFrame = face_recognition.face_locations(imgS)
                SecurityECurFrame = face_recognition.face_encodings(imgS, SecurityFCurFrame)

                for sencodedFace, faceLoc in zip(SecurityECurFrame, SecurityFCurFrame):
                    matches = face_recognition.compare_faces(encoded_security_list, sencodedFace)
                    flag = 0
                    for match in matches:
                        if match == TRUE:
                            flag = flag + 1
                    if flag == 0:
                        Report = Report + "\n" + "Unauthorized Face Detected @" + str(datetime.now()) + " in " + pth
                        name = "Security_Report/" + str(datetime.now()) + ".jpg"
                        name = name.replace(" ", "")
                        name = name.replace("-", "_")
                        name = name.replace(":", "_")
                        status = cv2.imwrite(name, img)
                        print(status)
        cv2.imshow('Webcam', img)
        cv2.waitKey(1)


# function to create new rooms in the window
def new_room():
    print("New room added")
    num = len(Rooms)
    txt = "Room" + str(num + 1)
    Rooms.append(txt)
    btn = Button(root, text=txt, command=lambda: rooms_work(txt))
    btn.pack(side=LEFT)
    directory = txt
    path = os.path.join(parent_dir, directory)
    os.mkdir(path)


label1 = Label(root, text="Logo Goes here")
label1.pack()
# label['text'] = "New Label text"
# label["font"] = ("Courier", 20)
label1.configure(text="FR Attendance", font=("Courier", 20))

button1 = Button(root, text="Add Room", command=new_room)
button1.pack()
button2 = Button(root, text="Reports", command=reports)
button2.pack()
button3 = Button(root, text="Room1", command=lambda: rooms_work("Room1"))
button3.pack(side=LEFT)
Rooms.append("Room1")
label2 = Label(root, text='')
label2.pack(side=tk.BOTTOM)

root.mainloop()
